# YAREM - Yet Another Rust Error Macro

A simple but relatively easy to use Rust error macro. New errors can be 
defined using the `error!` macro as follows

```
#[macro_use] extern crate yarem;
/// A comment for this error that will be visible in the docs
error!(ErrorName, "The message that will be shown to the user");
```

In addition, errors can be combined using the `errors!` macro

```
#[macro_use] extern crate yarem;
// Names should be imported with a unique name
use std::io::{Error as IOError};

error!(CustomError, "A custom error");

errors!(IoOrCustom; IOError, CustomError);
```

This can then be used in the `Result` objects of functions, for example

```
#[macro_use] extern crate yarem;
use std::io::{Error as IOError};
use std::fs::File;

error!(CustomError, "A custom error");
errors!(IoOrCustom; IOError, CustomError);

fn bar() -> Result<(), CustomError> { Ok(()) }

fn foo() -> Result<(), IoOrCustom> {
  File::open("foo/foo")?;
  bar()?;
  Ok(())
}
```

The `errors!` Macro
-------------------

Define a new error that is an enumeration over all the possible values, i.e,
works as an algebraic union of the types. `Error`, `Display` and  `From` are
implemented for this new error type. For example `errors!(X; A, B)` generates:

```
/// Definitions (not generated by errors! macro)
#[macro_use] extern crate yarem;
fn main() {} 
error!(A, "A");
error!(B, "B");

/// Code below is generated
#[derive(Debug)]
pub enum X {
    A(A),
    B(B)
}

impl ::std::error::Error for X {
  fn description(&self) -> &str {
    match *self {
      X::A(ref a) => a.description(),
      X::B(ref b) => b.description()
    }
  }

  fn cause(&self) -> Option<&::std::error::Error> {
    match *self {
      X::A(ref a) => Some(a),
      X::B(ref b) => Some(b)
    }
  }
}

impl ::std::fmt::Display for X {
  fn fmt(&self, f : &mut::std::fmt::Formatter) 
      -> Result<(), ::std::fmt::Error> {
    match *self {
      X::A(ref a) => a.fmt(f),
      X::B(ref b) => b.fmt(f)
    }
  }
}

impl From<A> for X {
  fn from(a : A) -> X { X::A(a) }
}

impl From<B> for X {
  fn from(b : B) -> X { X::B(b) }
}
```

The `error!` macro
------------------

Define a new error with an appropriate error message as its description,
e.g., `error!(A, "message")` expands to

```
#[derive(Debug)]
pub struct A;

impl ::std::error::Error for A {
  fn description(&self) -> &str { "message" }
}

impl ::std::fmt::Display for A {
  fn fmt(&self, f : &mut ::std::fmt::Formatter) 
    -> Result<(), ::std::fmt::Error> {
    write!(f, "{}", "message")
  }
}
```

